# Charless

# === 数字のみ言語 設計仕様 (案) ===

## 1. 基本コンセプト
- 使用する文字は 0 から 9 の数字のみ。

## 2. 特別な数字（予約語）
- 20: トークン（単語）間の区切り文字 (スペースの役割)
- 99: 「数値リテラル」モードの開始を宣言するプレフィックス

## 3. 字句解析 (トークンの区切り方)
コンパイラは、以下のルールで数字の並びをトークンに分割する。

1.  文字列の先頭から読み込む。
2.  次に出現する「20 (区切り)」または「99 (数値モード開始)」を探す。
3.  その手前までの数字の並びを、1つの「命令トークン」として解釈する。
4.  「20」または「99」自体も、それぞれ1つのトークンとして解釈する。

(例: `112205099` は `[命令(112)]` `[区切り(20)]` `[命令(50)]` `[数値モード開始(99)]` に分割される)

## 4. 数値リテラルの表現 (99)
数値をコードの一部として埋め込む方法。

1.  `99` トークンで「数値リテラル」モードを開始する。
2.  `99` の直後に続く数字の並びは、次に出現する `20` (区切り) まで、すべて1つの「数値」として解釈される。
3.  このモード中は、`20` 以外の数字（`99` や他の命令番号を含む）はすべて数値の一部として扱われる。

(例: 数値 `10` を表現 $\rightarrow$ `99` `10` `20`)
(例: 数値 `20` を表現 $\rightarrow$ `99` `20` `20`)

## 5. 文字列 (連続可変長データ) の表現
特定の命令（例: `01` = 出力命令）に続くデータとして定義する。

1.  形式は「長さプレフィックス」方式を採用する。
2.  フォーマット: `[桁数][データ本体]`
    - `[桁数]` : `[データ本体]` の桁数を表す数字。
    - `[データ本体]` : 実際のデータ（文字コードなど）。
3.  この `[桁数][データ本体]` のペアは、次の `20` (区切り) が出現するまで、連続して並べることができる。

(例: "a" = 1000 (4桁), "b" = 1001 (4桁), "z" = 98765 (5桁) と仮定)
(例: "abz" という文字列データを表現 $\rightarrow$ `41000` `41001` `598765`)

## 6. プログラムの例
(仮に `50` = push, `01` = print_string と定義)

(例1: `push 20` を実行)
- `50` (push命令)
- `20` (区切り)
- `99` (数値モード開始)
- `20` (数値 `20` 本体)
- `20` (区切り)
- $\rightarrow$ `5020992020`

(例2: "abc" (a=1000, b=1001, c=1010) を出力)
- `01` (print_string命令)
- `20` (区切り)
- `41000` ("a")
- `41001` ("b")
- `41010` ("c")
- `20` (区切り)
- $\rightarrow$ `012041000410014101020`
